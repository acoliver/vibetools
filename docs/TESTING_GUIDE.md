# Testing Guide

## Path Aliases & Jest Configuration

1. In `tsconfig.json`, define path aliases (e.g. `@services/*`, `@ui/*`, etc.).
2. Mirror those aliases in `jest.config.js` under `moduleNameMapper`:
   ```js
   moduleNameMapper: {
     '^@services/(.*)$': '<rootDir>/src/services/$1',
     '^@ui/(.*)$': '<rootDir>/src/ui/$1',
     // ...other mappings...
   }
   ```
3. Always use path aliases (e.g. `@services/...`), never deep relative imports (`../../../services/...`).

## Mocking Strategy & Lint/Type Safety

- All `jest.mock()` calls must appear before any imports of the code under test.
- Always use `jest.Mocked<T>` to strongly type your stubs/mocks. If you must, use `as unknown as jest.Mocked<T>`.
- Never use `any` or `@ts-ignore` for mocks. Always type your stubs properly.
- Use `jest.clearAllMocks()` in every `beforeEach` block.
- Remove unused mocks/imports, or prefix with `_` to satisfy ESLint.
- Follow the project's semicolon and quotes style.

### Example: Strongly-Typed Singleton Service Mock

```typescript
import { describe, test, beforeEach, expect, jest } from '@jest/globals';
import type { MyService } from '@services/my/MyService';

// 1. Build a typed stub
const mockMyService = {
  doSomething: jest.fn().mockResolvedValue(true),
  getValue: jest.fn().mockReturnValue(42)
} as jest.Mocked<MyService>;

// 2. Override the module before import
jest.mock('@services/my/MyService', () => ({
  MyService: { getInstance: () => mockMyService }
}));

// 3. Import the code under test
import { myHandler } from '@services/my/myHandler';

describe('myHandler', () => {
  beforeEach(() => jest.clearAllMocks());
  test('calls MyService', async () => {
    await myHandler();
    expect(mockMyService.doSomething).toHaveBeenCalled();
  });
});
```

### Creating Minimal Domain Fixtures

When working with domain models (e.g. `ChangeProposal`, `DiffChunk`, `FileDiff`), import types and enums, and create minimal fixtures to satisfy the interfaces:

```typescript
import type { ChangeProposal } from '@models/ChangeProposal';
import { ChangeProposalStatus } from '@models/ChangeProposal';
import type { DiffChunk, FileDiff } from '@models/FileDiff';
import { FileDiffStatus } from '@models/FileDiff';
import type { DiffManager } from '@services/diff/DiffManager';

const proposalStub: ChangeProposal = {
  id: 'proposal-123',
  timestamp: Date.now(),
  title: 'Test Proposal',
  description: 'Generated by unit test',
  files: [],
  status: ChangeProposalStatus.PENDING,
  lastModified: new Date().toISOString()
};

const diffChunkStub: DiffChunk = {
  index: 0,
  originalStartLine: 1,
  originalLineCount: 1,
  modifiedStartLine: 1,
  modifiedLineCount: 1,
  type: 'modification',
  content: '// patch for chunk',
  contextBefore: '',
  contextAfter: ''
};

const fileDiffStub: FileDiff = {
  id: 'diff-123',
  filePath: 'src/file.ts',
  isNewFile: false,
  originalContent: 'old content',
  modifiedContent: 'new content',
  description: '',
  status: FileDiffStatus.PENDING
};

const mockDiffManager: jest.Mocked<DiffManager> = {
  createProposal: jest.fn().mockResolvedValue(proposalStub),
  parseUnifiedDiff: jest.fn().mockReturnValue([diffChunkStub]),
  addFileDiff: jest.fn().mockResolvedValue(fileDiffStub),
  getProposal: jest.fn().mockReturnValue(proposalStub),
  onDidChangeProposal: jest.fn(),
  onDidChangeFileDiff: jest.fn(),
  addChangeListener: jest.fn(),
  removeChangeListener: jest.fn()
} as unknown as jest.Mocked<DiffManager>;
```

## Common Pitfalls and How to Avoid Them

| Pitfall                                        | Solution                                          |
|------------------------------------------------|---------------------------------------------------|
| `Argument of type ... is not assignable to never` | Use `jest.Mocked<T>` for all stubs/mocks.         |
| `Cannot find module` with pathâ€‘alias imports     | Check `moduleNameMapper` in `jest.config.js`.      |
| Explicit `any` or `@ts-ignore` everywhere        | Use strong types for mocks, never `any` or `@ts-ignore`. |
| Deep relative imports                            | Always use `@alias/...` imports.                   |

## Testing Framework

LLRT uses Jest for testing, with the following key configuration:
## Best Practices

1. **Test in Isolation**: Mock dependencies to isolate the component under test.
2. **Mirror File Organization**: Keep test file structure similar to the source code.
3. **Use Path Aliases**: Use the same path aliases in tests as in the source code, never deep relative imports.
4. **Test Edge Cases**: Include tests for error conditions and edge cases.
5. **Test Services Thoroughly**: Services contain the core business logic and should have the most comprehensive tests.
6. **Keep UI Tests Focused**: UI tests should focus on rendering and event handling, not business logic.
7. **Use beforeEach/afterEach**: Set up and tear down test state consistently. Always call `jest.clearAllMocks()` in `beforeEach`.
8. **Strong Typing for Mocks**: Always use `jest.Mocked<T>` for mocks and stubs.
9. **No `any` or `@ts-ignore`**: Never use these in tests. Fix types properly.
10. **Remove Unused Variables**: Remove or prefix with `_` to satisfy ESLint.
11. **Follow Style Guide**: Use project semicolons and quotes.

    // Verify expected services were called
    expect(mockService.method).toHaveBeenCalledWith("arg1", "arg2");
  });
```

---

With these patterns, your tests will remain strongly-typed, robust, and lint-compliant. You can now maintain and extend tests without referring to a separate mocking strategy document.